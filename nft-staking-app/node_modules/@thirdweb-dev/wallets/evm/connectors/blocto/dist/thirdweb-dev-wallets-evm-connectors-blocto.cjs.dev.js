'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var defineProperty = require('../../../../dist/defineProperty-982e7acf.cjs.dev.js');
var WagmiConnector = require('../../../../dist/WagmiConnector-6ff7d562.cjs.dev.js');
var errors = require('../../../../dist/errors-e4b137ea.cjs.dev.js');
var BloctoSDK = require('@blocto/sdk');
var ethers = require('ethers');
var walletIds = require('../../../../dist/walletIds-0e1ebc43.cjs.dev.js');
var url = require('../../../../dist/url-4b641c31.cjs.dev.js');
var normalizeChainId = require('../../../../dist/normalizeChainId-5da85f42.cjs.dev.js');
require('@thirdweb-dev/chains');
require('eventemitter3');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var BloctoSDK__default = /*#__PURE__*/_interopDefault(BloctoSDK);

class BloctoConnector extends WagmiConnector.WagmiConnector {
  constructor(_ref) {
    let {
      chains,
      options = {}
    } = _ref;
    super({
      chains,
      options
    });
    defineProperty._defineProperty(this, "id", walletIds.walletIds.blocto);
    defineProperty._defineProperty(this, "name", "Blocto");
    defineProperty._defineProperty(this, "ready", true);
    this._onAccountsChangedBind = this.onAccountsChanged.bind(this);
    this._onChainChangedBind = this.onChainChanged.bind(this);
    this._onDisconnectBind = this.onDisconnect.bind(this);
  }
  async connect(config) {
    try {
      const provider = await this.getProvider(config);
      this.setupListeners();
      this.emit("message", {
        type: "connecting"
      });
      const accounts = await provider.request({
        method: "eth_requestAccounts"
      });
      const account = ethers.utils.getAddress(accounts[0]);
      const id = await this.getChainId();
      const unsupported = this.isChainUnsupported(id);
      return {
        account,
        chain: {
          id,
          unsupported
        },
        provider
      };
    } catch (error) {
      this._handleConnectReset();
      if (this._isUserRejectedRequestError(error)) {
        throw new errors.UserRejectedRequestError(error);
      }
      throw error;
    }
  }
  async disconnect() {
    const provider = await this.getProvider();
    await provider.request({
      method: "wallet_disconnect"
    });
    this.removeListeners();
    this._handleConnectReset();
  }
  async getAccount() {
    const provider = await this.getProvider();
    const accounts = await provider.request({
      method: "eth_accounts"
    });
    const [address] = accounts || [];
    if (!address) {
      throw new Error("No accounts found");
    }
    return address;
  }
  async getChainId() {
    const provider = await this.getProvider();
    const chainId = await provider.request({
      method: "eth_chainId"
    });
    return normalizeChainId.normalizeChainId(chainId);
  }
  getProvider() {
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this._provider) {
      const _chainId = chainId ?? this.options.chainId ?? this.chains[0]?.chainId ?? 1;
      const _rpc = this.chains.find(x => x.chainId === _chainId)?.rpc[0];
      this._provider = new BloctoSDK__default["default"]({
        ethereum: {
          chainId: _chainId,
          rpc: _rpc
        },
        appId: this.options.appId
      })?.ethereum;
    }
    if (!this._provider) {
      throw new errors.ConnectorNotFoundError();
    }
    return Promise.resolve(this._provider);
  }
  async getSigner() {
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);
    return new ethers.providers.Web3Provider(provider, chainId).getSigner(account);
  }
  async isAuthorized() {
    return !!this._provider?._blocto?.sessionKey ?? false;
  }
  async switchChain(chainId) {
    const provider = await this.getProvider();
    const id = ethers.utils.hexValue(chainId);
    const chain = this.chains.find(x => x.chainId === chainId);
    if (!chain) {
      throw new errors.SwitchChainError(new Error("chain not found on connector."));
    }
    const isBloctoSupportChain = provider._blocto.supportNetworkList[`${chainId}`];
    if (!isBloctoSupportChain) {
      throw new errors.SwitchChainError(new Error(`Blocto unsupported chain: ${id}`));
    }
    try {
      await provider.request({
        method: "wallet_addEthereumChain",
        params: [{
          chainId: id,
          rpcUrls: url.getValidPublicRPCUrl(chain) // no client id on purpose here
        }]
      });
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: id
        }]
      });
      return chain;
    } catch (error) {
      if (this._isUserRejectedRequestError(error)) {
        throw new errors.UserRejectedRequestError(error);
      }
      throw new errors.SwitchChainError(error);
    }
  }
  onAccountsChanged() {
    // not supported yet
  }
  async onChainChanged(chain) {
    const id = normalizeChainId.normalizeChainId(chain);
    const unsupported = this.isChainUnsupported(id);
    const account = await this.getAccount();
    this.emit("change", {
      chain: {
        id,
        unsupported
      },
      account
    });
  }
  onDisconnect() {
    this.emit("disconnect");
  }
  async setupListeners() {
    const provider = await this.getProvider();
    provider.on("accountsChanged", this._onAccountsChangedBind);
    provider.on("chainChanged", this._onChainChangedBind);
    provider.on("disconnect", this._onDisconnectBind);
  }
  async removeListeners() {
    const provider = await this.getProvider();
    provider.off("accountsChanged", this._onAccountsChangedBind);
    provider.off("chainChanged", this._onChainChangedBind);
    provider.off("disconnect", this._onDisconnectBind);
  }
  _isUserRejectedRequestError(error) {
    return /(user rejected)/i.test(error.message);
  }
  _handleConnectReset() {
    this._provider = undefined;
  }
}

exports.BloctoConnector = BloctoConnector;
