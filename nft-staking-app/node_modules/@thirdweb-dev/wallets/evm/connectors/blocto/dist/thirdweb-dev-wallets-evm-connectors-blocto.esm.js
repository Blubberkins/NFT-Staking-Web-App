import { _ as _defineProperty } from '../../../../dist/defineProperty-d067c271.esm.js';
import { W as WagmiConnector } from '../../../../dist/WagmiConnector-6011bbb1.esm.js';
import { U as UserRejectedRequestError, a as ConnectorNotFoundError, S as SwitchChainError } from '../../../../dist/errors-b8627438.esm.js';
import BloctoSDK from '@blocto/sdk';
import { utils, providers } from 'ethers';
import { w as walletIds } from '../../../../dist/walletIds-aafeafc7.esm.js';
import { g as getValidPublicRPCUrl } from '../../../../dist/url-0d129c6b.esm.js';
import { n as normalizeChainId } from '../../../../dist/normalizeChainId-abcb61d5.esm.js';
import '@thirdweb-dev/chains';
import 'eventemitter3';

class BloctoConnector extends WagmiConnector {
  constructor(_ref) {
    let {
      chains,
      options = {}
    } = _ref;
    super({
      chains,
      options
    });
    _defineProperty(this, "id", walletIds.blocto);
    _defineProperty(this, "name", "Blocto");
    _defineProperty(this, "ready", true);
    this._onAccountsChangedBind = this.onAccountsChanged.bind(this);
    this._onChainChangedBind = this.onChainChanged.bind(this);
    this._onDisconnectBind = this.onDisconnect.bind(this);
  }
  async connect(config) {
    try {
      const provider = await this.getProvider(config);
      this.setupListeners();
      this.emit("message", {
        type: "connecting"
      });
      const accounts = await provider.request({
        method: "eth_requestAccounts"
      });
      const account = utils.getAddress(accounts[0]);
      const id = await this.getChainId();
      const unsupported = this.isChainUnsupported(id);
      return {
        account,
        chain: {
          id,
          unsupported
        },
        provider
      };
    } catch (error) {
      this._handleConnectReset();
      if (this._isUserRejectedRequestError(error)) {
        throw new UserRejectedRequestError(error);
      }
      throw error;
    }
  }
  async disconnect() {
    const provider = await this.getProvider();
    await provider.request({
      method: "wallet_disconnect"
    });
    this.removeListeners();
    this._handleConnectReset();
  }
  async getAccount() {
    const provider = await this.getProvider();
    const accounts = await provider.request({
      method: "eth_accounts"
    });
    const [address] = accounts || [];
    if (!address) {
      throw new Error("No accounts found");
    }
    return address;
  }
  async getChainId() {
    const provider = await this.getProvider();
    const chainId = await provider.request({
      method: "eth_chainId"
    });
    return normalizeChainId(chainId);
  }
  getProvider() {
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this._provider) {
      const _chainId = chainId ?? this.options.chainId ?? this.chains[0]?.chainId ?? 1;
      const _rpc = this.chains.find(x => x.chainId === _chainId)?.rpc[0];
      this._provider = new BloctoSDK({
        ethereum: {
          chainId: _chainId,
          rpc: _rpc
        },
        appId: this.options.appId
      })?.ethereum;
    }
    if (!this._provider) {
      throw new ConnectorNotFoundError();
    }
    return Promise.resolve(this._provider);
  }
  async getSigner() {
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);
    return new providers.Web3Provider(provider, chainId).getSigner(account);
  }
  async isAuthorized() {
    return !!this._provider?._blocto?.sessionKey ?? false;
  }
  async switchChain(chainId) {
    const provider = await this.getProvider();
    const id = utils.hexValue(chainId);
    const chain = this.chains.find(x => x.chainId === chainId);
    if (!chain) {
      throw new SwitchChainError(new Error("chain not found on connector."));
    }
    const isBloctoSupportChain = provider._blocto.supportNetworkList[`${chainId}`];
    if (!isBloctoSupportChain) {
      throw new SwitchChainError(new Error(`Blocto unsupported chain: ${id}`));
    }
    try {
      await provider.request({
        method: "wallet_addEthereumChain",
        params: [{
          chainId: id,
          rpcUrls: getValidPublicRPCUrl(chain) // no client id on purpose here
        }]
      });
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: id
        }]
      });
      return chain;
    } catch (error) {
      if (this._isUserRejectedRequestError(error)) {
        throw new UserRejectedRequestError(error);
      }
      throw new SwitchChainError(error);
    }
  }
  onAccountsChanged() {
    // not supported yet
  }
  async onChainChanged(chain) {
    const id = normalizeChainId(chain);
    const unsupported = this.isChainUnsupported(id);
    const account = await this.getAccount();
    this.emit("change", {
      chain: {
        id,
        unsupported
      },
      account
    });
  }
  onDisconnect() {
    this.emit("disconnect");
  }
  async setupListeners() {
    const provider = await this.getProvider();
    provider.on("accountsChanged", this._onAccountsChangedBind);
    provider.on("chainChanged", this._onChainChangedBind);
    provider.on("disconnect", this._onDisconnectBind);
  }
  async removeListeners() {
    const provider = await this.getProvider();
    provider.off("accountsChanged", this._onAccountsChangedBind);
    provider.off("chainChanged", this._onChainChangedBind);
    provider.off("disconnect", this._onDisconnectBind);
  }
  _isUserRejectedRequestError(error) {
    return /(user rejected)/i.test(error.message);
  }
  _handleConnectReset() {
    this._provider = undefined;
  }
}

export { BloctoConnector };
