"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[317],{34057:function(t,r,e){e.d(r,{D:function(){return p},F:function(){return l},I:function(){return c},a:function(){return d},b:function(){return uploadOrExtractURI},c:function(){return fetchTokenMetadataForContract},f:function(){return fetchTokenMetadata},g:function(){return getBaseUriFromBatch},u:function(){return uploadOrExtractURIs}});var a=e(44715),i=e(16441),n=e(2593),o=e(64146),s=e(48764).Buffer;let c=i.arrayify("0x80ac58cd"),d=i.arrayify("0xd9b67a26"),l={name:"Failed to load NFT metadata"};async function fetchTokenMetadata(t,r,e){let o;if(r.startsWith("data:application/json;base64")&&void 0!==s){let e=r.split(",")[1],i=JSON.parse(s.from(e,"base64").toString("utf-8"));return a.C.parse({...i,id:n.O$.from(t).toString(),uri:r})}let c=r.replace("{id}",i.hexZeroPad(n.O$.from(t).toHexString(),32).slice(2));try{o=await e.downloadJSON(c)}catch(i){let a=r.replace("{id}",n.O$.from(t).toString());try{o=await e.downloadJSON(a)}catch(e){console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:r})} -- falling back to default metadata`),o=l}}return a.C.parse({...o,id:n.O$.from(t).toString(),uri:r})}async function fetchTokenMetadataForContract(t,r,i,s){let p;let u=(await e.e(5025).then(e.t.bind(e,25025,19))).default,g=new o.CH(t,u,r),[f,h]=await Promise.all([g.supportsInterface(c),g.supportsInterface(d)]);if(f){let a=(await Promise.resolve().then(e.t.bind(e,34161,19))).default,n=new o.CH(t,a,r);p=await n.tokenURI(i)}else if(h){let a=(await Promise.resolve().then(e.t.bind(e,50266,19))).default,n=new o.CH(t,a,r);p=await n.uri(i)}else throw Error("Contract must implement ERC 1155 or ERC 721.");return p?fetchTokenMetadata(i,p,s):a.C.parse({...l,id:n.O$.from(i).toString(),uri:""})}async function uploadOrExtractURI(t,r){return"string"==typeof t?t:await r.upload(a.a.parse(t))}async function uploadOrExtractURIs(t,r,e,i){if(void 0===t.find(t=>"string"!=typeof t))return t;if(void 0===t.find(t=>"object"!=typeof t)){let n=await r.uploadBatch(t.map(t=>a.a.parse(t)),{rewriteFileNames:{fileStartNumber:e||0},onProgress:i?.onProgress});return n}throw Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function getBaseUriFromBatch(t){let r=t[0].substring(0,t[0].lastIndexOf("/"));for(let e=0;e<t.length;e++){let a=t[e].substring(0,t[e].lastIndexOf("/"));if(r!==a)throw Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${r}' but got '${a}'`)}return r.replace(/\/$/,"")+"/"}let p=100},56451:function(t,r,e){e.d(r,{c:function(){return cleanCurrencyAddress}});var a=e(73699),i=e(92518);function cleanCurrencyAddress(t){return(0,i.i)(t)?a.aV:t}},72555:function(t,r,e){e.d(r,{C:function(){return ContractInterceptor}});let ContractInterceptor=class ContractInterceptor{constructor(t){this.contractWrapper=t}overrideNextTransaction(t){this.contractWrapper.withTransactionOverride(t)}}},70279:function(t,r,e){e.d(r,{C:function(){return ContractPlatformFee}});var a=e(7457),i=e(73699);let ContractPlatformFee=class ContractPlatformFee{featureName=i.dp.name;constructor(t){this.contractWrapper=t}async get(){let[t,r]=await this.contractWrapper.read("getPlatformFeeInfo",[]);return i.bF.parseAsync({platform_fee_recipient:t,platform_fee_basis_points:r})}set=(0,a.d)(async t=>{let r=await i.bF.parseAsync(t);return a.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPlatformFeeInfo",args:[r.platform_fee_recipient,r.platform_fee_basis_points]})})}},75872:function(t,r,e){e.d(r,{a:function(){return isWinningBid},g:function(){return getAllInBatches},h:function(){return handleTokenApproval},i:function(){return isTokenApprovedForTransfer},m:function(){return mapOffer},v:function(){return validateNewListingParam}});var a=e(64146),i=e(2593),n=e(38776),o=e(34057),s=e(73699),c=e(92518);async function isTokenApprovedForTransfer(t,r,i,n,s){try{let c=(await e.e(5025).then(e.t.bind(e,25025,19))).default,d=new a.CH(i,c,t),[l,p]=await Promise.all([d.supportsInterface(o.I),d.supportsInterface(o.a)]);if(l){let o;let c=(await Promise.resolve().then(e.t.bind(e,70332,19))).default,d=new a.CH(i,c,t),l=await d.isApprovedForAll(s,r);if(l)return!0;try{o=await d.getApproved(n)}catch(t){}return o?.toLowerCase()===r.toLowerCase()}if(!p)return console.error("Contract does not implement ERC 1155 or ERC 721."),!1;{let n=(await Promise.resolve().then(e.t.bind(e,8455,19))).default,o=new a.CH(i,n,t);return await o.isApprovedForAll(s,r)}}catch(t){return console.error("Failed to check if token is approved",t),!1}}async function handleTokenApproval(t,r,a,i,n){let c=(await e.e(5025).then(e.t.bind(e,25025,19))).default,d=new s.cq(t.getSignerOrProvider(),a,c,t.options,t.storage),[l,p]=await Promise.all([d.read("supportsInterface",[o.I]),d.read("supportsInterface",[o.a])]);if(l){let o=(await Promise.resolve().then(e.t.bind(e,70332,19))).default,c=new s.cq(t.getSignerOrProvider(),a,o,t.options,t.storage),d=await c.read("isApprovedForAll",[n,r]);if(!d){let t=(await c.read("getApproved",[i])).toLowerCase()===r.toLowerCase();t||await c.sendTransaction("setApprovalForAll",[r,!0])}}else if(p){let i=(await Promise.resolve().then(e.t.bind(e,8455,19))).default,o=new s.cq(t.getSignerOrProvider(),a,i,t.options,t.storage),c=await o.read("isApprovedForAll",[n,r]);c||await o.sendTransaction("setApprovalForAll",[r,!0])}else throw Error("Contract must implement ERC 1155 or ERC 721.")}function validateNewListingParam(t){(0,n.Z)(void 0!==t.assetContractAddress&&null!==t.assetContractAddress,"Asset contract address is required"),(0,n.Z)(void 0!==t.buyoutPricePerToken&&null!==t.buyoutPricePerToken,"Buyout price is required"),(0,n.Z)(void 0!==t.listingDurationInSeconds&&null!==t.listingDurationInSeconds,"Listing duration is required"),(0,n.Z)(void 0!==t.startTimestamp&&null!==t.startTimestamp,"Start time is required"),(0,n.Z)(void 0!==t.tokenId&&null!==t.tokenId,"Token ID is required"),(0,n.Z)(void 0!==t.quantity&&null!==t.quantity,"Quantity is required"),"NewAuctionListing"===t.type&&(0,n.Z)(void 0!==t.reservePricePerToken&&null!==t.reservePricePerToken,"Reserve price is required")}async function mapOffer(t,r,e){return{quantity:e.quantityDesired,pricePerToken:e.pricePerToken,currencyContractAddress:e.currency,buyerAddress:e.offeror,quantityDesired:e.quantityWanted,currencyValue:await (0,c.a)(t,e.currency,e.quantityWanted.mul(e.pricePerToken)),listingId:r}}function isWinningBid(t,r,e){if(e=i.O$.from(e),t=i.O$.from(t),r=i.O$.from(r),t.eq(i.O$.from(0)))return!1;let a=r.sub(t).mul(s.dz).div(t);return a.gte(e)}async function getAllInBatches(t,r,e){let a=[];for(;r-t>o.D;)a.push(e(t,t+o.D-1)),t+=o.D;return a.push(e(t,r-1)),await Promise.all(a)}},317:function(t,r,e){e.r(r),e.d(r,{Marketplace:function(){return Marketplace}});var a,i=e(2593),n=e(9279),o=e(61744),s=e(21046),c=e(19485),d=e(64146),l=e(38776),p=e(34057),u=e(92518),g=e(73699),f=e(75872),h=e(7457),w=e(46024),m=e(72555),y=e(70279),W=e(78201),v=e(56451),A=e(25894),C=e(44715);let T=((a={})[a.Direct=0]="Direct",a[a.Auction=1]="Auction",a);e(13550),e(62822),e(71770);let MarketplaceAuction=class MarketplaceAuction{constructor(t,r){this.contractWrapper=t,this.storage=r,this.encoder=new u.C(t)}getAddress(){return this.contractWrapper.address}async getListing(t){let r=await this.contractWrapper.read("listings",[t]);if(r.listingId.toString()!==t.toString())throw new g.L(this.getAddress(),t.toString());if(r.listingType!==T.Auction)throw new g.W(this.getAddress(),t.toString(),"Direct","Auction");return await this.mapListing(r)}async getWinningBid(t){await this.validateListing(i.O$.from(t));let r=await this.contractWrapper.read("winningBid",[t]);if(r.offeror!==n.d)return await (0,f.m)(this.contractWrapper.getProvider(),i.O$.from(t),r)}async getWinner(t){let r=await this.validateListing(i.O$.from(t)),e=await this.contractWrapper.read("winningBid",[t]),a=i.O$.from(Math.floor(Date.now()/1e3)),o=i.O$.from(r.endTimeInEpochSeconds);if(a.gt(o)&&e.offeror!==n.d)return e.offeror;let s=new w.a(this.contractWrapper),c=await s.getEvents("AuctionClosed"),d=c.find(r=>r.data.listingId.eq(i.O$.from(t)));if(!d)throw Error(`Could not find auction with listingId ${t} in closed auctions`);return d.data.winningBidder}createListing=(0,h.d)(async t=>{(0,f.v)(t);let r=await (0,g.aL)(t.assetContractAddress),e=await (0,g.aL)(t.currencyContractAddress);await (0,f.h)(this.contractWrapper,this.getAddress(),r,t.tokenId,await this.contractWrapper.getSignerAddress());let a=await (0,A.n)(this.contractWrapper.getProvider(),t.buyoutPricePerToken,e),n=await (0,A.n)(this.contractWrapper.getProvider(),t.reservePricePerToken,e),o=Math.floor(t.startTimestamp.getTime()/1e3),s=await this.contractWrapper.getProvider().getBlock("latest"),c=s.timestamp;return o<c&&(o=c),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createListing",args:[{assetContract:r,tokenId:t.tokenId,buyoutPricePerToken:a,currencyToAccept:(0,v.c)(e),listingType:T.Auction,quantityToList:t.quantity,reservePricePerToken:n,secondsUntilEndTime:t.listingDurationInSeconds,startTime:i.O$.from(o)}],parse:t=>{let r=this.contractWrapper.parseLogs("ListingAdded",t?.logs);return{id:r[0].args.listingId,receipt:t}}})});createListingsBatch=(0,h.d)(async t=>{let r=(await Promise.all(t.map(t=>this.createListing.prepare(t)))).map(t=>t.encode());return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>{let r=this.contractWrapper.parseLogs("ListingAdded",t?.logs);return r.map(r=>({id:r.args.listingId,receipt:t}))}})});buyoutListing=(0,h.d)(async t=>{let r=await this.validateListing(i.O$.from(t)),e=await (0,u.f)(this.contractWrapper.getProvider(),r.currencyContractAddress);return this.makeBid.prepare(t,o.formatUnits(r.buyoutPrice,e.decimals))});makeBid=(0,h.d)(async(t,r)=>{let e=await this.validateListing(i.O$.from(t)),a=await (0,A.n)(this.contractWrapper.getProvider(),r,e.currencyContractAddress);if(a.eq(i.O$.from(0)))throw Error("Cannot make a bid with 0 value");let n=await this.contractWrapper.read("bidBufferBps",[]),o=await this.getWinningBid(t);if(o){let t=(0,f.a)(o.pricePerToken,a,n);(0,l.Z)(t,"Bid price is too low based on the current winning bid and the bid buffer")}else{let t=i.O$.from(e.reservePrice);(0,l.Z)(a.gte(t),"Bid price is too low based on reserve price")}let c=i.O$.from(e.quantity),d=a.mul(c),p=await this.contractWrapper.getCallOverrides()||{};return await (0,C.s)(this.contractWrapper,d,e.currencyContractAddress,p),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"offer",args:[t,e.quantity,e.currencyContractAddress,a,s.Bz],overrides:p})});cancelListing=(0,h.d)(async t=>{let r=await this.validateListing(i.O$.from(t)),e=i.O$.from(Math.floor(Date.now()/1e3)),a=i.O$.from(r.startTimeInEpochSeconds),o=await this.contractWrapper.read("winningBid",[t]);if(e.gt(a)&&o.offeror!==n.d)throw new g.t(t.toString());return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"closeAuction",args:[i.O$.from(t),await this.contractWrapper.getSignerAddress()]})});closeListing=(0,h.d)(async(t,r)=>{r||(r=await this.contractWrapper.getSignerAddress());let e=await this.validateListing(i.O$.from(t));try{return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"closeAuction",args:[i.O$.from(t),r]})}catch(r){if(r.message.includes("cannot close auction before it has ended"))throw new g.w(t.toString(),e.endTimeInEpochSeconds.toString());throw r}});executeSale=(0,h.d)(async t=>{let r=await this.validateListing(i.O$.from(t));try{let e=await this.getWinningBid(t);(0,l.Z)(e,"No winning bid found");let a=this.encoder.encode("closeAuction",[t,r.sellerAddress]),i=this.encoder.encode("closeAuction",[t,e.buyerAddress]);return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a,i]})}catch(e){if(e.message.includes("cannot close auction before it has ended"))throw new g.w(t.toString(),r.endTimeInEpochSeconds.toString());throw e}});updateListing=(0,h.d)(async t=>h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateListing",args:[t.id,t.quantity,t.reservePrice,t.buyoutPrice,t.currencyContractAddress,t.startTimeInEpochSeconds,t.endTimeInEpochSeconds]}));async getBidBufferBps(){return this.contractWrapper.read("bidBufferBps",[])}async getMinimumNextBid(t){let[r,e,a]=await Promise.all([this.getBidBufferBps(),this.getWinningBid(t),this.validateListing(i.O$.from(t))]),n=e?e.currencyValue.value:a.reservePrice,o=n.add(n.mul(r).div(1e4));return(0,u.a)(this.contractWrapper.getProvider(),a.currencyContractAddress,o)}async validateListing(t){try{return await this.getListing(t)}catch(r){throw console.error(`Error getting the listing with id ${t}`),r}}async mapListing(t){return{assetContractAddress:t.assetContract,buyoutPrice:i.O$.from(t.buyoutPricePerToken),currencyContractAddress:t.currency,buyoutCurrencyValuePerToken:await (0,u.a)(this.contractWrapper.getProvider(),t.currency,t.buyoutPricePerToken),id:t.listingId.toString(),tokenId:t.tokenId,quantity:t.quantity,startTimeInEpochSeconds:t.startTime,asset:await (0,p.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),reservePriceCurrencyValuePerToken:await (0,u.a)(this.contractWrapper.getProvider(),t.currency,t.reservePricePerToken),reservePrice:i.O$.from(t.reservePricePerToken),endTimeInEpochSeconds:t.endTime,sellerAddress:t.tokenOwner,type:T.Auction}}};let MarketplaceDirect=class MarketplaceDirect{constructor(t,r){this.contractWrapper=t,this.storage=r}getAddress(){return this.contractWrapper.address}async getListing(t){let r=await this.contractWrapper.read("listings",[t]);if(r.assetContract===n.d)throw new g.L(this.getAddress(),t.toString());if(r.listingType!==T.Direct)throw new g.W(this.getAddress(),t.toString(),"Auction","Direct");return await this.mapListing(r)}async getActiveOffer(t,r){await this.validateListing(i.O$.from(t)),(0,l.Z)(c.isAddress(r),"Address must be a valid address");let e=await this.contractWrapper.read("offers",[t,await (0,g.aL)(r)]);if(e.offeror!==n.d)return await (0,f.m)(this.contractWrapper.getProvider(),i.O$.from(t),e)}createListing=(0,h.d)(async t=>{(0,f.v)(t);let r=await (0,g.aL)(t.assetContractAddress),e=await (0,g.aL)(t.currencyContractAddress);await (0,f.h)(this.contractWrapper,this.getAddress(),r,t.tokenId,await this.contractWrapper.getSignerAddress());let a=await (0,A.n)(this.contractWrapper.getProvider(),t.buyoutPricePerToken,e),n=Math.floor(t.startTimestamp.getTime()/1e3),o=await this.contractWrapper.getProvider().getBlock("latest"),s=o.timestamp;return n<s&&(n=s),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createListing",args:[{assetContract:r,tokenId:t.tokenId,buyoutPricePerToken:a,currencyToAccept:(0,v.c)(e),listingType:T.Direct,quantityToList:t.quantity,reservePricePerToken:a,secondsUntilEndTime:t.listingDurationInSeconds,startTime:i.O$.from(n)}],parse:t=>{let r=this.contractWrapper.parseLogs("ListingAdded",t?.logs);return{id:r[0].args.listingId,receipt:t}}})});createListingsBatch=(0,h.d)(async t=>{let r=(await Promise.all(t.map(t=>this.createListing.prepare(t)))).map(t=>t.encode());return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>{let r=this.contractWrapper.parseLogs("ListingAdded",t?.logs);return r.map(r=>({id:r.args.listingId,receipt:t}))}})});makeOffer=(0,h.d)(async(t,r,e,a,n)=>{if((0,u.i)(e))throw Error("You must use the wrapped native token address when making an offer with a native token");let o=await (0,A.n)(this.contractWrapper.getProvider(),a,e);try{await this.getListing(t)}catch(r){throw console.error("Failed to get listing, err =",r),Error(`Error getting the listing with id ${t}`)}let c=i.O$.from(r),d=i.O$.from(o).mul(c),l=await this.contractWrapper.getCallOverrides()||{};await (0,C.s)(this.contractWrapper,d,e,l);let p=s.Bz;return n&&(p=i.O$.from(Math.floor(n.getTime()/1e3))),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"offer",args:[t,r,e,o,p],overrides:l})});acceptOffer=(0,h.d)(async(t,r)=>{await this.validateListing(i.O$.from(t));let e=await (0,g.aL)(r),a=await this.contractWrapper.read("offers",[t,e]);return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"acceptOffer",args:[t,e,a.currency,a.pricePerToken]})});buyoutListing=(0,h.d)(async(t,r,e)=>{let a=await this.validateListing(i.O$.from(t)),{valid:n,error:o}=await this.isStillValidListing(a,r);if(!n)throw Error(`Listing ${t} is no longer valid. ${o}`);let s=e||await this.contractWrapper.getSignerAddress(),c=i.O$.from(r),d=i.O$.from(a.buyoutPrice).mul(c),l=await this.contractWrapper.getCallOverrides()||{};return await (0,C.s)(this.contractWrapper,d,a.currencyContractAddress,l),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"buy",args:[t,s,c,a.currencyContractAddress,d],overrides:l})});updateListing=(0,h.d)(async t=>h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateListing",args:[t.id,t.quantity,t.buyoutPrice,t.buyoutPrice,await (0,g.aL)(t.currencyContractAddress),t.startTimeInSeconds,t.secondsUntilEnd]}));cancelListing=(0,h.d)(async t=>h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelDirectListing",args:[t]}));async validateListing(t){try{return await this.getListing(t)}catch(r){throw console.error(`Error getting the listing with id ${t}`),r}}async mapListing(t){return{assetContractAddress:t.assetContract,buyoutPrice:i.O$.from(t.buyoutPricePerToken),currencyContractAddress:t.currency,buyoutCurrencyValuePerToken:await (0,u.a)(this.contractWrapper.getProvider(),t.currency,t.buyoutPricePerToken),id:t.listingId.toString(),tokenId:t.tokenId,quantity:t.quantity,startTimeInSeconds:t.startTime,asset:await (0,p.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),secondsUntilEnd:t.endTime,sellerAddress:t.tokenOwner,type:T.Direct}}async isStillValidListing(t,r){let a=await (0,f.i)(this.contractWrapper.getProvider(),this.getAddress(),t.assetContractAddress,t.tokenId,t.sellerAddress);if(!a)return{valid:!1,error:`Token '${t.tokenId}' from contract '${t.assetContractAddress}' is not approved for transfer`};let i=this.contractWrapper.getProvider(),n=(await e.e(5025).then(e.t.bind(e,25025,19))).default,o=new d.CH(t.assetContractAddress,n,i),s=await o.supportsInterface(p.I),c=await o.supportsInterface(p.a);if(s){let r;let a=(await Promise.resolve().then(e.t.bind(e,70332,19))).default,n=new d.CH(t.assetContractAddress,a,i);try{r=await n.ownerOf(t.tokenId)}catch(t){}let o=r?.toLowerCase()===t.sellerAddress.toLowerCase();return{valid:o,error:o?void 0:`Seller is not the owner of Token '${t.tokenId}' from contract '${t.assetContractAddress} anymore'`}}if(!c)return{valid:!1,error:"Contract does not implement ERC 1155 or ERC 721."};{let a=(await Promise.resolve().then(e.t.bind(e,8455,19))).default,n=new d.CH(t.assetContractAddress,a,i),o=await n.balanceOf(t.sellerAddress,t.tokenId),s=o.gte(r||t.quantity);return{valid:s,error:s?void 0:`Seller does not have enough balance of Token '${t.tokenId}' from contract '${t.assetContractAddress} to fulfill the listing`}}}};let Marketplace=class Marketplace{static contractRoles=g.dB;get chainId(){return this._chainId}constructor(t,r,e){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=arguments.length>4?arguments[4]:void 0,n=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:new g.cq(t,r,i,a,e);this._chainId=n,this.abi=g.bj.parse(i||[]),this.contractWrapper=o,this.storage=e,this.metadata=new w.C(this.contractWrapper,g.bZ,this.storage),this.app=new w.b(this.contractWrapper,this.metadata,this.storage),this.roles=new W.C(this.contractWrapper,Marketplace.contractRoles),this.encoder=new u.C(this.contractWrapper),this.estimator=new w.G(this.contractWrapper),this.direct=new MarketplaceDirect(this.contractWrapper,this.storage),this.auction=new MarketplaceAuction(this.contractWrapper,this.storage),this.events=new w.a(this.contractWrapper),this.platformFees=new y.C(this.contractWrapper),this.interceptor=new m.C(this.contractWrapper)}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async getListing(t){let r=await this.contractWrapper.read("listings",[t]);if(r.assetContract===n.d)throw new g.L(this.getAddress(),t.toString());switch(r.listingType){case T.Auction:return await this.auction.mapListing(r);case T.Direct:return await this.direct.mapListing(r);default:throw Error(`Unknown listing type: ${r.listingType}`)}}async getActiveListings(t){let r=await this.getAllListingsNoFilter(!0),e=this.applyFilter(r,t),a=i.O$.from(Math.floor(Date.now()/1e3));return e.filter(t=>t.type===T.Auction&&i.O$.from(t.endTimeInEpochSeconds).gt(a)&&i.O$.from(t.startTimeInEpochSeconds).lte(a)||t.type===T.Direct&&i.O$.from(t.quantity).gt(0))}async getAllListings(t){let r=await this.getAllListingsNoFilter(!1);return this.applyFilter(r,t)}getAll=this.getAllListings;async getTotalCount(){return await this.contractWrapper.read("totalListings",[])}async isRestrictedToListerRoleOnly(){let t=await this.contractWrapper.read("hasRole",[(0,g.H)("lister"),n.d]);return!t}async getBidBufferBps(){return this.contractWrapper.read("bidBufferBps",[])}async getTimeBufferInSeconds(){return this.contractWrapper.read("timeBuffer",[])}async getOffers(t){let r=await this.events.getEvents("NewOffer",{order:"desc",filters:{listingId:t}});return await Promise.all(r.map(r=>(0,f.m)(this.contractWrapper.getProvider(),i.O$.from(t),{quantityWanted:r.data.quantityWanted,pricePerToken:r.data.quantityWanted.gt(0)?r.data.totalOfferAmount.div(r.data.quantityWanted):r.data.totalOfferAmount,currency:r.data.currency,offeror:r.data.offeror})))}buyoutListing=(0,h.d)(async(t,r,e)=>{let a=await this.contractWrapper.read("listings",[t]);if(a.listingId.toString()!==t.toString())throw new g.L(this.getAddress(),t.toString());switch(a.listingType){case T.Direct:return(0,l.Z)(void 0!==r,"quantityDesired is required when buying out a direct listing"),await this.direct.buyoutListing.prepare(t,r,e);case T.Auction:return await this.auction.buyoutListing.prepare(t);default:throw Error(`Unknown listing type: ${a.listingType}`)}});makeOffer=(0,h.d)(async(t,r,e)=>{let a=await this.contractWrapper.read("listings",[t]);if(a.listingId.toString()!==t.toString())throw new g.L(this.getAddress(),t.toString());let i=await this.contractWrapper.getChainID();switch(a.listingType){case T.Direct:return(0,l.Z)(e,"quantity is required when making an offer on a direct listing"),await this.direct.makeOffer.prepare(t,e,(0,u.i)(a.currency)?g.aW[i].wrapped.address:a.currency,r);case T.Auction:return await this.auction.makeBid.prepare(t,r);default:throw Error(`Unknown listing type: ${a.listingType}`)}});setBidBufferBps=(0,h.d)(async t=>{await this.roles.verify(["admin"],await this.contractWrapper.getSignerAddress());let r=await this.getTimeBufferInSeconds();return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAuctionBuffers",args:[r,i.O$.from(t)]})});setTimeBufferInSeconds=(0,h.d)(async t=>{await this.roles.verify(["admin"],await this.contractWrapper.getSignerAddress());let r=await this.getBidBufferBps();return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAuctionBuffers",args:[i.O$.from(t),r]})});allowListingFromSpecificAssetOnly=(0,h.d)(async t=>{let r=[],e=await this.roles.get("asset");return e.includes(n.d)&&r.push(this.encoder.encode("revokeRole",[(0,g.H)("asset"),n.d])),r.push(this.encoder.encode("grantRole",[(0,g.H)("asset"),t])),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r]})});allowListingFromAnyAsset=(0,h.d)(async()=>{let t=[],r=await this.roles.get("asset");for(let e in r)t.push(this.encoder.encode("revokeRole",[(0,g.H)("asset"),e]));return t.push(this.encoder.encode("grantRole",[(0,g.H)("asset"),n.d])),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[t]})});async getAllListingsNoFilter(t){let r=await Promise.all(Array.from(Array((await this.contractWrapper.read("totalListings",[])).toNumber()).keys()).map(async r=>{let e;try{e=await this.getListing(r)}catch(t){if(t instanceof g.L)return;console.warn(`Failed to get listing ${r}' - skipping. Try 'marketplace.getListing(${r})' to get the underlying error.`);return}if(e.type===T.Auction)return e;if(t){let{valid:t}=await this.direct.isStillValidListing(e);if(!t)return}return e}));return r.filter(t=>void 0!==t)}applyFilter(t,r){let e=[...t],a=i.O$.from(r?.start||0).toNumber(),n=i.O$.from(r?.count||p.D).toNumber();return r&&(r.seller&&(e=e.filter(t=>t.sellerAddress.toString().toLowerCase()===r?.seller?.toString().toLowerCase())),r.tokenContract&&(e=e.filter(t=>t.assetContractAddress.toString().toLowerCase()===r?.tokenContract?.toString().toLowerCase())),void 0!==r.tokenId&&(e=e.filter(t=>t.tokenId.toString()===r?.tokenId?.toString())),e=(e=e.filter((t,r)=>r>=a)).slice(0,n)),e}async prepare(t,r,e){return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:t,args:r,overrides:e})}async call(t,r,e){return this.contractWrapper.call(t,r,e)}}},44715:function(t,r,e){e.d(r,{B:function(){return c},C:function(){return p},N:function(){return l},a:function(){return d},s:function(){return setErc20Allowance}});var a=e(73699),i=e(1604),n=e(92518);let o=i.z.object({}).catchall(i.z.union([a.cw,i.z.unknown()])),s=i.z.union([i.z.array(o),o]).optional().nullable(),c=i.z.object({name:i.z.union([i.z.string(),i.z.number()]).optional().nullable(),description:i.z.string().nullable().optional().nullable(),image:a.cx.nullable().optional(),animation_url:a.cx.optional().nullable()}),d=c.extend({external_url:a.cx.nullable().optional(),background_color:a.cy.optional().nullable(),properties:s,attributes:s}).catchall(i.z.union([a.cw,i.z.unknown()])),l=i.z.union([d,i.z.string()]),p=d.extend({id:i.z.string(),uri:i.z.string(),image:i.z.string().nullable().optional(),external_url:i.z.string().nullable().optional(),animation_url:i.z.string().nullable().optional()});async function setErc20Allowance(t,r,i,o){if((0,n.i)(i))o.value=r;else{let n=(await Promise.resolve().then(e.t.bind(e,49242,19))).default,s=t.getSigner(),c=t.getProvider(),d=new a.cq(s||c,i,n,t.options,t.storage),l=await t.getSignerAddress(),p=t.address,u=await d.read("allowance",[l,p]);return u.lt(r)&&await d.sendTransaction("approve",[p,r]),o}}}}]);