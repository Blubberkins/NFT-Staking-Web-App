"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6081],{34057:function(t,a,e){e.d(a,{D:function(){return d},F:function(){return p},I:function(){return c},a:function(){return l},b:function(){return uploadOrExtractURI},c:function(){return fetchTokenMetadataForContract},f:function(){return fetchTokenMetadata},g:function(){return getBaseUriFromBatch},u:function(){return uploadOrExtractURIs}});var r=e(44715),n=e(16441),o=e(2593),s=e(64146),i=e(48764).Buffer;let c=n.arrayify("0x80ac58cd"),l=n.arrayify("0xd9b67a26"),p={name:"Failed to load NFT metadata"};async function fetchTokenMetadata(t,a,e){let s;if(a.startsWith("data:application/json;base64")&&void 0!==i){let e=a.split(",")[1],n=JSON.parse(i.from(e,"base64").toString("utf-8"));return r.C.parse({...n,id:o.O$.from(t).toString(),uri:a})}let c=a.replace("{id}",n.hexZeroPad(o.O$.from(t).toHexString(),32).slice(2));try{s=await e.downloadJSON(c)}catch(n){let r=a.replace("{id}",o.O$.from(t).toString());try{s=await e.downloadJSON(r)}catch(e){console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:a})} -- falling back to default metadata`),s=p}}return r.C.parse({...s,id:o.O$.from(t).toString(),uri:a})}async function fetchTokenMetadataForContract(t,a,n,i){let d;let u=(await e.e(5025).then(e.t.bind(e,25025,19))).default,h=new s.CH(t,u,a),[f,y]=await Promise.all([h.supportsInterface(c),h.supportsInterface(l)]);if(f){let r=(await Promise.resolve().then(e.t.bind(e,34161,19))).default,o=new s.CH(t,r,a);d=await o.tokenURI(n)}else if(y){let r=(await Promise.resolve().then(e.t.bind(e,50266,19))).default,o=new s.CH(t,r,a);d=await o.uri(n)}else throw Error("Contract must implement ERC 1155 or ERC 721.");return d?fetchTokenMetadata(n,d,i):r.C.parse({...p,id:o.O$.from(n).toString(),uri:""})}async function uploadOrExtractURI(t,a){return"string"==typeof t?t:await a.upload(r.a.parse(t))}async function uploadOrExtractURIs(t,a,e,n){if(void 0===t.find(t=>"string"!=typeof t))return t;if(void 0===t.find(t=>"object"!=typeof t)){let o=await a.uploadBatch(t.map(t=>r.a.parse(t)),{rewriteFileNames:{fileStartNumber:e||0},onProgress:n?.onProgress});return o}throw Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function getBaseUriFromBatch(t){let a=t[0].substring(0,t[0].lastIndexOf("/"));for(let e=0;e<t.length;e++){let r=t[e].substring(0,t[e].lastIndexOf("/"));if(a!==r)throw Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${a}' but got '${r}'`)}return a.replace(/\/$/,"")+"/"}let d=100},26081:function(t,a,e){e.d(a,{C:function(){return ContractRoyalty},D:function(){return DelayedReveal},a:function(){return ContractOwner},c:function(){return calculateClaimCost}});var r=e(46024),n=e(7457),o=e(73699),s=e(92518),i=e(29251),c=e(31886),l=e(84243),p=e(16441),d=e(2593),u=e(64146),h=e(44715),f=e(34057),y=e(90737),g=e(25894);let ContractRoyalty=class ContractRoyalty{featureName=o.d1.name;constructor(t,a){this.contractWrapper=t,this.metadata=a}async getDefaultRoyaltyInfo(){let[t,a]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return o.bD.parseAsync({fee_recipient:t,seller_fee_basis_points:a})}async getTokenRoyaltyInfo(t){let[a,e]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return o.bD.parseAsync({fee_recipient:a,seller_fee_basis_points:e})}setDefaultRoyaltyInfo=(0,n.d)(async t=>{let a=await this.metadata.get(),e=await this.metadata.parseInputMetadata({...a,...t}),o=await this.metadata._parseAndUploadMetadata(e);if((0,r.h)("setContractURI",this.contractWrapper)){let t=new s.C(this.contractWrapper),a=[t.encode("setDefaultRoyaltyInfo",[e.fee_recipient,e.seller_fee_basis_points]),t.encode("setContractURI",[o])];return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}throw Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")});setTokenRoyaltyInfo=(0,n.d)(async(t,a)=>{let e=o.bD.parse(a);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,e.fee_recipient,e.seller_fee_basis_points],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})})};let DelayedReveal=class DelayedReveal{constructor(t,a,e,r){this.featureName=e,this.nextTokenIdToMintFn=r,this.contractWrapper=t,this.storage=a}createDelayedRevealBatch=(0,n.d)(async(t,a,e,r)=>{let o;if(!e)throw Error("Password is required");let s=await this.storage.uploadBatch([h.a.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),p=(0,f.g)(s),d=await this.nextTokenIdToMintFn(),u=await this.storage.uploadBatch(a.map(t=>h.a.parse(t)),{onProgress:r?.onProgress,rewriteFileNames:{fileStartNumber:d.toNumber()}}),y=(0,f.g)(u),g=await this.contractWrapper.read("getBaseURICount",[]),w=await this.hashDelayRevealPassword(g,e),m=await this.contractWrapper.read("encryptDecrypt",[i.Y0(y),w]),I=await this.isLegacyContract();if(I)o=m;else{let t=await this.contractWrapper.getChainID(),a=c.keccak256(["bytes","bytes","uint256"],[i.Y0(y),w,t]);o=l.$.encode(["bytes","bytes32"],[m,a])}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[u.length,p.endsWith("/")?p:`${p}/`,o],parse:t=>{let a=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),e=a[0].args.startTokenId,r=a[0].args.endTokenId,n=[];for(let a=e;a.lte(r);a=a.add(1))n.push({id:a,receipt:t});return n}})});reveal=(0,n.d)(async(t,a)=>{if(!a)throw Error("Password is required");let e=await this.hashDelayRevealPassword(t,a);try{let a=await this.contractWrapper.callStatic().reveal(t,e);if(!a.includes("://")||!a.endsWith("/"))throw Error("invalid password")}catch(t){throw Error("invalid password")}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,e]})});async getBatchesToReveal(){let t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];let a=Array.from(Array(t.toNumber()).keys()),e=await Promise.all(a.map(t=>{if((0,r.h)("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[t]);if((0,r.h)("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[t]);throw Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")})),n=e.slice(0,e.length-1),o=await Promise.all(Array.from([0,...n]).map(t=>this.getNftMetadata(t.toString()))),s=await this.isLegacyContract(),i=await Promise.all(Array.from([...e]).map(t=>s?this.getLegacyEncryptedData(t):this.contractWrapper.read("encryptedData",[t]))),c=i.map(t=>{if(!(p.hexDataLength(t)>0))return t;{if(s)return t;let a=l.$.decode(["bytes","bytes32"],t);return a[0]}});return o.map((t,a)=>({batchId:d.O$.from(a),batchUri:t.uri,placeholderMetadata:t})).filter((t,a)=>p.hexDataLength(c[a])>0)}async hashDelayRevealPassword(t,a){let e=await this.contractWrapper.getChainID(),r=this.contractWrapper.address;return c.keccak256(["string","uint256","uint256","address"],[a,e,t,r])}async getNftMetadata(t){return(0,f.c)(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if((0,r.h)("contractVersion",this.contractWrapper))try{let t=await this.contractWrapper.read("contractVersion",[]);return t<=2}catch(t){}return!1}async getLegacyEncryptedData(t){let a=(await e.e(8839).then(e.t.bind(e,98839,19))).default,r=new u.CH(this.contractWrapper.address,a,this.contractWrapper.getProvider()),n=await r.functions.encryptedBaseURI(t);return n.length>0?n[0]:"0x"}};async function calculateClaimCost(t,a,e,r,n){let s={},i=r||o.aV,c=await (0,g.n)(t.getProvider(),a,i),l=c.mul(e);return l.gt(0)&&(i===o.aV?s={value:l}:i!==o.aV&&n&&await (0,y.a)(t,i,l,e,0)),s}let ContractOwner=class ContractOwner{featureName=o.d2.name;constructor(t){this.contractWrapper=t}async get(){return this.contractWrapper.read("owner",[])}set=(0,n.d)(async t=>{let a=await (0,o.aL)(t);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[a]})})}}}]);